# Edem Template - Документация
*Edem Template далее будет обозначаться как "шаблон"*

Любая работа с новым и неизведанным должна начинаться с документации. Проблема лишь в том, что не каждая документация написана простым и понятным языком. Я постарался написать документацию так, как будто я сам впервые ее читаю, чтобы все было максимально понятно и не вызывало проблем при работе с шаблоном *(но это не точно)*.  

**Прежде чем начать**  

Мой телеграм для связи - <a href="https://t.me/korgmen" target="_blank">@Korgmen</a>  

<a href="https://boosty.to/korgmen/donate" target="_blank">Поблагодарить меня за труды можно тут</a>  


## Оглавление

1. [Вводная часть](#вводная-часть)
	1. [Что такое Edem Template](#что-такое-edem-template)
	2. [Основные возможности и преимущества](#основные-возможности-и-преимущества)
	3. [Краткая история создания](#краткая-история-создания)
	4. [АТТЕНТЮЙОН](#аттентюйон)
2. [Установка и запуск](#установка-и-запуск)
	1. [Клонирование](#клонирование)
	2. [Интеграция зависимых файлов шаблона](#интеграция-зависимых-файлов-шаблона)
	3. [Установка зависимостей](#установка-зависимостей)
	4. [Запуск сборки (режим разработки и продакшн)](#запуск-сборки-режим-разработки-и-продакшн)
	5. [Остановка сборки](#остановка-сборки)
3. [Подготовка к верстке](#подготовка-к-верстке)
	1. [Как я начинаю верстку](#как-я-начинаю-верстку)
4. [Структура шаблона](#структура-шаблона)
	1. [Общая структура папок и файлов](#общая-структура-папок-и-файлов)
	2. [Назначение основных директорий](#назначение-основных-директорий)
	3. [Назначение основных файлов](#назначение-основных-файлов)
5. [HTML](#html)
	1. [Система HTML-чанков](#система-html-чанков)
6. [Именование классов](#именование-классов)
	1. [Базовая структура страницы](#базовая-структура-страницы)
	2. [Примечания по некоторым монолитным классам](#примечания-по-некоторым-монолитным-классам)
	3. [Кастомные именования](#кастомные-именования)
7. [CSS/SCSS](#cssscss)
	1. [Структура SCSS](#структура-scss)
	2. [Встроенные компоненты шаблона](#встроенные-компоненты-шаблона)
	3. [Использование переменных, функций и миксинов](#использование-переменных-функций-и-миксинов)
	4. [Адаптивное свойство (lineScale-миксин)](#адаптивное-свойство-linescale-миксин)
	5. [Систематизация `z-index`](#систематизация-z-index)
	6. [Темизация и работа с темами](#темизация-и-работа-с-темами)
8. [JS-скрипты](#js-скрипты)
	1. [Структура JS](#структура-js)
	2. [Раздел 1. Технические модули](#раздел-1-технические-модули)
	3. [Раздел 2. Функциональные модули](#раздел-2-функциональные-модули)
	4. [Раздел 3. Формы](#раздел-3-формы)
	5. [Работа со сторонними библиотеками](#работа-со-сторонними-библиотеками)
9.  [Работа с изображениями и иконками](#работа-с-изображениями-и-иконками)
	 1. [Оптимизация изображений](#оптимизация-изображений)
	 2. [Генерация SVG-спрайта (работа с иконками)](#генерация-svg-спрайта-работа-с-иконками)
	 3. [svg-remove-fill](#svg-remove-fill)
	 4. [Подробнее об svg-спрайтах](#подробнее-об-svg-спрайтах)
10. [Шрифты](#шрифты)
	 1. [Генерация файлов шрифтов](#генерация-файлов-шрифтов)
	 2. [Подключение шрифтов](#подключение-шрифтов)
	 3. [Назначение заготовок стилей шрифтов](#назначение-заготовок-стилей-шрифтов)
11. [Зависимые файлы VSCode](#зависимые-файлы-vscode)
	 1. [Сниппеты](#сниппеты)
	 2. [Сочетания клавиш](#сочетания-клавиш)
	 3. [Настройки задач](#настройки-задач)
	 4. [Настройки VSCode](#настройки-vscode)
	 5. [Рекомендованные расширения](#рекомендованные-расширения)
12. [Система маркеров задач](#система-маркеров-задач)
	 1. [Как это работает?](#как-это-работает)
	 2. [Типы маркеров](#типы-маркеров)
13. [Автоматический деплой на сервер](#автоматический-деплой-на-сервер)
14. [Скрипты для MODX](#скрипты-для-modx)
15. [Полезные советы](#полезные-советы)
16. [Часто задаваемые вопросы](#часто-задаваемые-вопросы)
17. [Заключение](#заключение)
	 1. [Благодарности](#благодарности)
	 2. [Контакты для обратной связи](#контакты-для-обратной-связи)
	 3. [Планы на будущее развитие шаблона](#планы-на-будущее-развитие-шаблона)


## Вводная часть

### Что такое Edem Template
Это не просто Gulp-сборка, это объемный инструмент для верстальщиков, желающих ускорить свою работу и быть готовым к любым задачам на пути "хардкорной верстки".

### Основные возможности и преимущества

В шаблоне вы найдете множество скриптов-модулей, которые реализуют те или иные функции *(например: боковое меню, модальные окна, спойлеры, табы и прочее)*, готовые решения: настройки для VSCode, сниппеты, сочетания клавиш и тд. Это объемный "продукт", который потребует времени для ознакомления, но в итоге станет для вас незаменимым компаньоном.

### Краткая история создания
Меня зовут Роман Лебедев, я более семи лет занимаюсь веб-разработкой.  
Для верстки сайтов я достаточно долгое время использовал Gulp-сборку, которую собирал в 2019 году по видео с ютуба. С тех пор мой скилл подрос *(надеюсь)*, но одно оставалось неизменным - старая Gulp-сборка, которая моментами работала плохо. С выходом пятой версии Gulp руки наконец дошли до обновления.  
Несколько недель я потратил на настройку сборщика, поиск и дефектовку старых и новых зависимостей, переезд на новую систему импорта Sass, на ES-модули, переписывание устаревших скриптов, допиливание функционала, который давно был на карандаше и написание документации ко всему этому.  
И теперь мне не стыдно *(возможно)* и я могу представить свой "продукт" для общего пользования.  

*Вполне вероятно, что я мог упустить какие-то моменты в этой документации, но со временем мы все поправим!*

**С чего начать?**  
Для начала конечно рекомендую ознакомиться с документацией ниже, а потом можно отправиться на стартовую страницу шаблона за дальнейшими указаниями *(файл `src/html/index.html`)*.  

### АТТЕНТЮЙОН
- Документация предполагает, что вы уже имеете опыт веб-разработки и ознакомлены со средой VSCode, со стандартными командами и их расположениями или сочетаниями клавиш для их вызова.  

- В некоторых местах документации будут использоваться клавиатурные сочетания шаблона вида `Ctrl+Shift+E|Option+Shift+E` (сочетание до вертикальной черты — для Windows, после — для MacOS), [подробнее о клавиатурных сочетаниях шаблона здесь.](#keybindings)  


## Установка и запуск

### Клонирование
Чтобы начать работу с шаблоном, необходимо склонировать этот репозиторий себе на устройство любым удобным способом.

### Интеграция зависимых файлов шаблона
Перед началом работы вы должны установить и выбрать профиль шаблона для VSCode. Это нужно, чтобы задействовать все зависимые файлы шаблона *(параметры, сниппеты, сочетания клавиш и задачи)*.  

Для этого нужно:
- Перейти в профили *(Шестеренка управления ➔ Профили)*;
- В выпадающем меню рядом с кнопкой "Новый профиль" выбрать пункт "Импортировать профиль";
- Далее необходимо выбрать файл профиля из папки `.vscode/EdemGulpTemplateProfile.code-profile` *(там лежит две версии: для MacOS и для Windows)*;
- Нажать кнопку "Создать" снизу вкладки;
- Согласиться с установкой расширений;
- Дождаться завершения процесса импорта;
- В списке профилей нажать на галочку рядом с EdemGulpTemplateProfile *(Использовать этот профиль для текущего окна)*;
- Готово.

Если вы хотите использовать профиль шаблона везде и всегда, установите галочку "Использовать этот профиль по умолчанию для новых окон" в настройках профиля EdemGulpTemplateProfile.  

[Подробнее о зависимых файлах шаблона здесь](#vscode-dependent).

### Установка зависимостей
В первую очередь необходимо подтянуть все зависимости, для этого используем команду VSCode `Tasks: Run Task` и в появившемся списке выбираем задачу **Подтягивание зависимостей**. *Также можно использовать клавиатурное сочетание шаблона `Ctrl+Shift+E|Option+Shift+E` для вызова списка задач.*  

*В шаблоне используется пакетный менеджер `pnpm` (преимущества гуглите), на него настроены все задачи сборки. <a href="https://pnpm.io/installation" target="_blank">Get started тут</a>.*  
> После выполнения данной команды будут загружены все необходимые для работы шаблона зависимости (папка node_modules).  

### Запуск сборки (режим разработки и продакшн)

#### Режим разработки (dev)
Для запуска основной задачи сборки *(режим разработки с запуском сервера)* необходимо использовать команду VSCode `Tasks: Run Build Task`. *Также можно использовать клавиатурное сочетание шаблона `Alt+E|Command+E` для запуска основной задачи сборки.*
> Данная команда запускает ряд действий, благодаря которым будет работать шаблон, а именно:  
> - Запуск веб-сервера и синхронизации, благодаря которым мы сможем увидеть сайт в браузере и следить за изменениями без необходимости обновлять страницу *(страница с сайтом откроется автоматически по окончании выполнения команды)*.  
**Примечание:** вы можете открыть страницу с сайтом с любого другого устройства, подключенного к той же сети, что и ПК, на котором запущен шаблон. Для этого в консоли необходимо посмотреть нужный URL (для внешнего подключения), он будет озаглавлен как **External**. Например: `External: http://192.168.0.103:3002`.  
Это удобно, например, для проверки мобильной версии сайта с телефона *(не забудьте подключить телефон к Wi-Fi)*;
> - Будет собран облегченный dev-вариант проекта для разработки. Все собранные файлы помещаются в папку `build`. Именно содержимое этой папки отображается в браузере.

#### Сборка в продакшн (build)
Для запуска сборки в продакшн используем команду VSCode `Tasks: Run Task` и в появившемся списке выбираем задачу **Сборка шаблона в продакшн**. *Также можно использовать клавиатурное сочетание шаблона `Ctrl+Shift+E|Option+Shift+E` для вызова списка задач.*
> - Данная команда запустит сборку продакшн-версии проекта, которая считается финальной и может быть передана заказчику;
> - **Чем отличается от dev-сборки?** Тут происходит ряд действий, которые просто не нужны в dev-сборке, а именно: оптимизация изображений, минификация JS и CSS файлов и еще несколько действий, которые облегчают финальный проект. Данная команда не запускает веб-сервер;

### Остановка сборки
Чтобы остановить работу сервера (и режима разработки), необходимо в консоли *(где запущена сборка)* использовать стандартное сочетание клавиш `Ctrl+C|Control+C`. *Также можно использовать клавиатурное сочетание шаблона `NaN|Command+Shift+E` для вызова списка задач для завершения.*  


## Подготовка к верстке

Чек-лист дел, которые нужно выполнить в шаблоне перед версткой проекта:  
- Отключить вызов файла `temp-theme.scss` в файле `src/scss/main.scss`. Это стили шаблона, которые нужны для визуализации стартовой страницы и некоторых компонентов (это следует сделать после ознакомления со страницей `src/html/index.html`, иначе там не будет стилей);
> В этом файле (`temp-theme.scss`) вы можете найти реализацию многих компонентов шаблона, а HTML-структуру компонентов можно увидеть в файле `src/html/_example.html`. В данный момент есть небольшая путаница с техническими классами и назначением стилей по ним *(половина стилей лежит внутри файла `temp-theme.scss`, а половина внутри компонентных файлов)*. В ближайшее время она будет поправлена.
- Собрать шрифты проекта и подключить их по инструкции из раздела [Шрифты](#шрифты);
- Собрать цветовую палитру проекта и прописать их по инструкции из раздела [Вызов цветов](#вызов-цветов);
- Собрать эффекты и прописать их по инструкции из раздела [Вызов эффектов](#вызов-эффектов);
- Подготовить иконки и разместить их в папке спрайта по инструкции из раздела [Генерация SVG-спрайта](#svg-generation);
- Собрать все изображения, либо взять какое-то одно как заглушку *(для верстки этого достаточно)*.

### Как я начинаю верстку
- Накидываю стили для стандартных компонентов сайта *(кнопки, заголовки и прочее)*;
- Далее перехожу к верстке страниц, начиная с главной *(страницы лежат по пути `src/html/pages/`)*. Строю структуру поблочно;
- После каждого блока перехожу к стилям для этого блока и его компонентам *(заранее определяя, есть ли подобные компоненты на сайте)*;
- Сразу делаю адаптив для блока;
- Перехожу к следующим блокам и повторяю шаги.

Файлы стилей уникальных блоков *(которые встречаются один раз на всем сайте)* помещаю в папку `src/scss/layout/`.  
Файлы стилей компонентов помещаю в папку `src/scss/components/`.  
Не забываем в начале каждого нового файла стилей подключать абстракции `@use 'abstracts' as *;` *(быстро добавить эту строку можно сниппетом `as`. Подробнее в разделе [Сниппеты](#сниппеты))*.  
Файлы стилей, которые вы помещаете в `src/scss/layout/` и `src/scss/components/` не нужно нигде прописывать, они генерируются автоматически силами сборки.  

Для быстрого создания файлов использую VSCode-расширение File Utils *(сочетание клавиш `Ctrl+Alt+N|Option+Command+N`)*.
Для навигации и поиска файлов использую встроенные функции VSCode *(сочетание клавиш `Ctrl+Shift+F|Command+Shift+F`)*.
Для быстрого поиска нужных стилей по классу так же использую встроенные функции VSCode *(сочетание клавиш `Ctrl+T|Command+T`)*.
Подробнее о сочетаниях клавиш и возможностях шаблона с ними в разделе [Сочетания клавиш](#сочетания-клавиш).  

Если вам нужен пример компонента или модуля шаблона, то их можно найти на странице с примерами `src/html/_example.html`.

## Структура шаблона

### Общая структура папок и файлов
Ниже представлена базовая структура шаблона.  
Для удобства все ключевые директории/файлы подписаны прямо в структуре.

	edemtmp/
	├── .vscode/
	│   ├── EdemGulpTemplateProfile_MacOS.code-profile ---> файл с профилем шаблона для MacOS
	│   └── EdemGulpTemplateProfile_Windows.code-profile ---> файл с профилем шаблона для Windows
	├── gulp/ ---> папка с логикой шаблона (трогаем, только если разбираемся)
	│   ├── config/
	│   │   └── plugins.js
	│   ├── plugins/
	│   │   └── remove-fill/
	│   │       ├── index.js
	│   │       └── README.md
	│   └── tasks/
	│       ├── font.js
	│       ├── generateIndexSCSS.js
	│       ├── html.js
	│       ├── img.js
	│       ├── js.js
	│       ├── reset.js
	│       ├── root.js
	│       ├── scss.js
	│       ├── server.js
	│       └── svg.js
	├── src/ ---> папка с файлами шаблона (нам сюда надо)
	│   ├── fonts/ ---> папка в которую нужно класть ваши шрифты
	│   │   └── [fonts].ttf ---> внутри папки лежат шрифты для демонстрации (можно удалить)
	│   ├── html/
	│   │   ├── chunks/ ---> папка с базовыми чанками из которых строится HTML-страница
	│   │   │   ├── breadcrumbs.html
	│   │   │   ├── footer.html
	│   │   │   ├── head.html
	│   │   │   ├── header.html
	│   │   │   ├── modals.html
	│   │   │   ├── navigation.html
	│   │   │   └── scripts.html
	│   │   ├── data/ ---> папка для работы с циклами gulp-file-include
	│   │   │   ├── parts/
	│   │   │   │   └── test-list.html
	│   │   │   └── test.json
	│   │   ├── pages/ ---> папка для HTML-страниц
	│   │   │   └── mainPage.html
	│   │   ├── _example.html ---> файл с примерами, демонстрирующими работу функций шаблона
	│   │   └── index.html ---> стартовая страница шаблона
	│   ├── img/
	│   │   ├── icons ---> папка с иконками для генерации svg-спрайта
	│   │   └── temp ---> папка с изображениями страницы примеров (можно удалить)
	│   ├── js/ ---> папка со скриптами шаблона (подробнее в разделе JS-скрипты)
	│   │   ├── libs/
	│   │   │   └── libs.js
	│   │   ├── modules/
	│   │   │   ├── form/
	│   │   │   ├── func/
	│   │   │   ├── lib-control/
	│   │   │   ├── tech/
	│   │   │   ├── utils/
	│   │   │   └── custom.js
	│   │   └── main.js
	│   ├── root/ ---> папка для файлов, которые после билда должны попасть в корень проекта
	│   │   ├── ConfusedTravolta.mp4 ---> заглушка для тестирования видео (можно удалить или использовать для разработки)
	│   │   └── favicon.svg
	│   └── scss/ ---> папка со стилями шаблона (подробнее в разделе SCSS-модули)
	│       ├── abstracts/
	│       │   ├── colors.scss
	│       │   ├── effects.scss
	│       │   ├── font-styles.scss
	│       │   ├── functions.scss
	│       │   ├── index.scss
	│       │   └── variables.scss
	│       ├── base/
	│       │   ├── fonts.scss
	│       │   ├── index.scss
	│       │   ├── null.scss
	│       │   └── timeline.scss
	│       ├── components/
	│       │   ├── form/
	│       │   └── ...
	│       ├── layout/
	│       ├── tech/
	│       │   ├── form/
	│       │   └── ...
	│       ├── themes/
	│       │   └── temp-theme.scss ---> файл со стилями для страниц шаблона (нужно удалить, подробнее в разделе Подготовка к верстке)
	│       └── main.scss
	├── .gitignore
	├── gulpfile.js ---> файл с настройками сборки
	├── package.json
	└── README.md

### Назначение основных директорий

### Назначение основных файлов


## HTML

### Система HTML-чанков

В шаблоне работает система чанков на основе пакета `gulp-file-include`, благодаря которому можно разделять HTML-файлы на блоки.  
Все чанки находятся в папке `html/chunks/`. Здесь есть основные стартовые чанки *(head, header, footer, modals и тд)*, которые уже подключены к стартовой странице. Помимо основных чанков, сюда вы можете добавлять свои собственные и вызывать их в любом месте страницы с помощью конструкции `@@include('../chunks/header.html')` (это пример для страницы внутри папки `pages`).  
Также есть возможность передавать параметры внутрь чанков, чтобы переиспользовать их в разных местах или страницах. Вот пример конструкции с передаваемым параметром `title` - `@@include('../chunks/head.html', {title: 'Главная страница'})`, при этом, внутри файла `head.html` должен быть указан параметр `@@title`, на место которого будет вставлен заголовок.  
Это не все возможности пакета `gulp-file-include`, но они наиболее часто используемые, если хотите узнать больше - [вот ссылка на репозиторий](https://github.com/haoxins/gulp-file-include).


## Именование классов
Общий подход в организации структуры и именование классов я делаю по БЭМ. Есть некоторые "монолитные классы", которые зафиксированы в каждом проекте и не меняются в связи со своей универсальностью. Также есть некоторые кастомные именования, которые продиктованы логикой шаблона.  

### Базовая структура страницы
Пример базовой структуры страницы, которая кочует от проекта к проекту и не меняется *(как раз тут используются монолитные классы)*:

	<body class="page"> --> для body всегда класс 'page'
		<div class="wrapper"> --> внутри body обертка с классом 'wrapper', всегда ее использую, помогает реализовать неожиданные дизайнерские запросы
			<header class="header"> --> для header всегда класс 'header'
				<div class="header__container"></div> --> внутри header ограничивающий контейнер с классом 'header__container'
			</header>
			<main class="content"> --> для main всегда класс 'content', на котором завязано многое далее по дереву
				<section class="content__block"> --> каждый уникальный раздел/блок страницы всегда с тегом section и классом-элементом 'content__block'
					<div class="content__container"> --> внутри раздела/блока всегда ограничивающий контейнер с классом-элементом 'content__container'
						<div class="custom-block"></div> --> тут уже можем встраивать структуру конкретного раздела/блока с уникальными классами
					</div>
				</section>
			</main>
			<footer class="footer"> --> для footer всегда класс 'footer'
				<div class="footer__container"></div> --> внутри footer ограничивающий контейнер с классом 'footer__container'
			</footer>
		</div>
	</body>

*Раньше я начинал разметку конкретных блоков прямо с тега `section`, типа `.content__block.custom-block ➔ .custom-block__container ➔ .custom-block__body` и тд, но отказался от такого подхода, так как он изначально заставляет вас создавать кучу пустых и не нужных классов. Теперь уникальные блоки начинаются внутри ограничивающего контейнера. А если необходимо изменить к примеру контейнер, можно обратиться к нему через селектор `:has`.*

### Примечания по некоторым монолитным классам
Большинство монолитных классов расположены в файле `src/scss/layout/base.scss`. Обязательно ознакомьтесь с этим файлом, чтобы понимать логику структуры выше.

`[какой-то-блок]__container` — такой класс можно применять исключительно к ограничивающим контейнерам, так как его стили завязаны на поиске всех классов содержащих `__container` *(`header__container`, `content__container`, `footer__container` и тд)*.

### Кастомные именования
Теперь затронем кастомные именования шаблона, которые не попадают под правила БЭМ.  

#### JS-классы
Такие классы нужны для работы со скриптами, чтобы находить и взаимодействовать с подобными элементами через скрипты.  
Выглядят такие классы вот так — `js_slider`, `js_tab`, `js_get-height` и тд, для отделения от обычных классов используется префикс `js_`.  
**С этими классами не должно быть стилевых взаимодействий, они нужны только для связки с JS и для технических стилей *(подробнее ниже)*.**  
Я рекомендую вам придерживаться такой же логики в своих проектах, если необходимо взаимодействовать с элементом через скрипты.  

**Зачем такое разделение?** Почему не использовать обычный нейминг или не обращаться к уже существующим классам?  
**Ответ:** чтобы банально не запутаться, а в дальнейшем не разрушить проект, чтобы другие разработчики понимали вашу логику и не превращали проект в легаси.  

#### Технические классы
Такие классы нужны для назначения технических стилей шаблона к некоторым блокам и элементам.  
Выглядят такие классы вот так — `_hide-menu`, `_checkbox`, `_burger-icon` и тд, для отделения от обычных классов используется нижнее подчеркивание `_`.  
**Не нужно оформлять блоки и элементы через эти классы, они нужны только для назначения технических *(базовых)* стилей под конкретные блоки/элементы.**  
Подробнее о работе с `CSS/SCSS` (в т.ч технических классах) в следующем [разделе](#css-scss).

*В будущем я планирую переработать логику технических классов, чтобы она была более очевидной для разработчиков, не знакомых с шаблоном.  
Так же на данный момент большинство технических стилей привязаны через JS-классы шаблона, что так же будет изменено.*

## <h2 id="css-scss">CSS/SCSS</h2>

### Структура SCSS

	scss/
	├── abstracts/ ---> тут хранятся файлы с переменными, функциями и тд. Т.е. файлы, которые напрямую не задают стили
	│   ├── colors.scss ---> цвета проекта
	│   ├── effects.scss ---> эффекты проекта
	│   ├── font-styles.scss ---> шрифтовые стили проекта
	│   ├── functions.scss ---> функции, миксины и тд
	│   ├── index.scss
	│   └── variables.scss ---> переменные проекта
	├── base/ ---> тут хранятся файлы с "базой" шаблона: подключение шрифтов, обнуляющие стили и тд.
	│   ├── fonts.scss ---> подключение шрифтов из папки src/fonts
	│   ├── index.scss
	│   ├── null.scss ---> обнуляющие стили
	│   └── timeline.scss ---> файл с заготовками анимаций для scroll-timeline
	├── components/ ---> стили компонентов проекта (так же тут находятся встроенные компоненты шаблона, подробнее об этом в соответствующем разделе)
	│   ├── form/ ---> компоненты форм
	│   └── ...
	├── layout/ ---> папка для стилей блоков проекта (шапка, футер и прочие чанки, которые не переиспользуются)
	├── tech/ ---> папка для технических стилей шаблона (подробнее об этом в разделе Встроенные компоненты шаблона)
	│   ├── form/ ---> технические стили форм
	│   └── ...
	└── themes/ ---> папка для тем проекта
	    └── main.scss ---> основной объединяющий файл стилей

### Встроенные компоненты шаблона
В шаблоне есть некоторые готовые компоненты (по типу табов, спойлеров, модалов и тд), в папке `src/scss/components/` находятся заготовки для этих и прочих встроенных компонентов.  
Самые масштабные компоненты описаны в разделе [JS-скрипты](#js-скрипты), чтобы не описывать один компонент два раза, я буду оставлять ссылки на раздел со скриптами для каждого такого случая. Все остальные компоненты будут описаны в текущем разделе.  

Так же для некоторых компонентов существуют технические стили, которые находятся в файлах с аналогичными названиями в директории `src/scss/tech/`. Технические стили - это постоянно необходимые стили для компонентов, которые отвечают за логику *(в то время, как файлы в директории `components` отвечают за внешний вид)*, но при желании вы можете их переопределить.  

#### Глоссарий
**Компонент-модификатор** – это компонент, к которому не привязан JS-скрипт. Достаточно лишь указан соответствующий класс.  
**Компонент-модуль** – это компонент, к которому привязан JS-скрипт. Подробнее о каждом такому модуле по ссылке, либо в разделе [JS-скрипты](#js-скрипты).  
**Компонент-блок** – это компонент, к которому не привязан JS-скрипт, но для его работы необходимо использовать HTML-конструкцию *(вызов каждой конструкции осуществляется через сниппет)*.

#### sans-serif. Компонент-модификатор
Требуется для обрамления alt-символов, если шрифт проекта не поддерживает нормальное их отображение, либо оно не соответствует ожиданиям. Примеры таких символов: ✓ © ♫ →
#### ruble. Компонент-модификатор
Требуется для обрамления символа рубля (₽), если шрифт проекта не поддерживает его нормальное отображение.
#### tooltip. Компонент-модуль
[Тултипы - подробнее](#initTooltip)
#### notify. Компонент-модуль
[Оповещения - подробнее](#initNotify)
#### cookie. Компонент-модуль
[Куки-оповещалка - подробнее](#initCookie)
#### slider-scrollbar. Компонент-модификатор
Требуется для назначения заготовки стилей для скроллбара Swiper-слайдера.
#### slider-pagination. Компонент-модификатор
Требуется для назначения заготовки стилей для пагинации Swiper-слайдера.  
#### slider-num. Компонент-модификатор
Это вариант пагинации Swiper-слайдера с нумерацией.
#### slider-pagination-custom. Компонент-блок
Это вариант пагинации Swiper-слайдера кастомного вида *(буллеты пагинации вы прописываете сами)*. Вызывается сниппетом `cmp|custom-pagination`.
#### slider-navigation. Компонент-блок
Это заготовка для навигации Swiper-слайдера. Вызывается сниппетом `cmp|swiper-navigation`.
#### modal. Компонент-модуль
[Модальные окна - подробнее](#initModals)
#### hide-menu. Компонент-блок
Это боковое меню, которое работает на логике модальных окон из предыдущего компонента. Сама заготовка бокового меню находится в файле `src/html/chunks/modals.html`.
#### tabs. Компонент-модуль
[Табы - подробнее](#initTabs)
#### spoiler-list. Компонент-модуль
[Спойлеры - подробнее](#initSpoilers)
#### text-content. Компонент-модификатор
Требуется для обрамления текстовых блоков. Здесь есть заготовка для заголовков, списков, изображений, таблиц и тд. Пример текстового блока можно увидеть в файле `src/html/_example.html`.  
***Зачем нужен этот компонент?** Обычно на сайте часто встречаются одинаковые текстовые блоки или контент статей, назначая этот класс на такие блоки, они все будут подтягивать одни стили.*
#### link. Компонент-модификатор
Требуется для обрамления ссылок на сайте.  
***Зачем нужен этот компонент?** Обычно все ссылки на сайте ведут себя одинаково, вы можете назначить для них стили в этом компоненте и использовать на всем сайте.*
#### button. Компонент-модификатор
Требуется для обрамления кнопок и их модификаций на сайте. По аналогии с предыдущим компонентом, но для кнопок.
#### title. Компонент-модификатор
Требуется для обрамления заголовков и их модификаций. По аналогии с предыдущим компонентом, но для заголовков.
#### icon. Компонент-модификатор
Требуется для обрамления иконок и svg-спрайтов, обычно не меняется из проекта в проект. Быстрый вызов заготовки под svg-спрайт через сниппет `svg`.
#### burger-icon. Компонент-блок
Это заготовка иконки бургера. Пример работы иконки можно увидеть в файле `src/html/_example.html`.  
Иконку можно настроить через файл `src/scss/abstracts/variables.scss` *(размер, кол-во линий и тд)*.  

---

**Далее идут компоненты форм**  
Примеры всех следующих компонентов можно увидеть в файле `src/html/_example.html`.

#### base
Файл с заготовкой стилей для форм. Сама форма под эти стили находится в файле `src/html/_example.html`.
#### checkbox
Этот компонент отвечает за оформление и работу чекбоксов и радио-кнопок.  
Это стандартный чекбокс с лейблом и кнопкой переключения. Например используется для подтверждение политики конфиденциальности.  
Вызывается сниппетом `cmp|checkbox`.
#### toggler-checkbox
Этот компонент отвечает за оформление и работу чекбокса-переключателя *(switch toggle)*.  
Это чекбокс-переключатель настроек или действий, где обычно и используется.  
Вызывается сниппетом `cmp|toggle-checkbox`.
#### custom-checkbox
Этот компонент отвечает за оформление и работу кастомных чекбоксов *(их примеры можно увидеть под формой в файле `src/html/_example.html`)*.  
Это чекбокс, который можно настроить как угодно. Обычно он выглядит как кнопка или как текст, при нажатии на который меняется цвет элемента.  
Вызывается сниппетом `cmp|custom-checkbox`.
#### number-input
Этот компонент отвечает за оформление и работу числовых полей ввода с кнопками + и -.  
Обычно используется как подтверждение политики конфиденциальности.  
Вызывается сниппетом `cmp|number-input`.
#### select
Этот компонент отвечает за оформление и работу выпадающего списка.  
Это стандартный выпадающий список без скриптов, стилизованный средствами CSS.  
Вызывается сниппетом `cmp|select`.
#### file-input
Этот компонент отвечает за оформление и работу файлового поля с кастомным оформлением и подстановкой названия файла.  
Вызывается сниппетом `cmp|file-input`.
#### range-input
Этот компонент отвечает за оформление и работу ползунка.  
Здесь применяются скрипты для вывода текущего значения и высчитывания его максимальной длины.  
Вызывается сниппетом `cmp|range-input`.
#### dual-range-input
Этот компонент отвечает за оформление и работу диапазонного ползунка.  
Здесь применяются скрипты для вывода текущего значения и высчитывания его максимальной длины.  
Двойной ползунок реализован стандартными средствами HTML/CSS с добавлением ограничений через скрипты.  
Вызывается сниппетом `cmp|dual-range-input`.
#### switch-this
Этот компонент отвечает за работу переключения видимости блоков через чекбокс.  
Для переключаемого блока необходимо задать атрибут `id` со значением, соответствующим этому блоку.  
Для чекбокса необходимо задать атрибут `data-switch` со значением из `id` переключаемого блока.  
Работает на нативном CSS с помощью селектора `:has`, без использования JS.

### Использование переменных, функций и миксинов

#### Вызов цветов
Цвета прописываются в файл `src/scss/abstracts/colors.scss`, там уже есть примеры цветов.  
Перед каждым цветом нужно выставить префикс `c-`, чтобы его можно было быстро найти через сниппет. Сниппет для быстрой вставки цвета - `vc`.

#### Вызов стилей шрифтов
Стили шрифтов прописываются через миксины в файле `src/scss/abstracts/font-styles.scss`, там уже есть примеры стилей шрифтов.  
Перед каждым миксином нужно выставить префикс `f-`, чтобы его можно было быстро найти через сниппет. Сниппет для быстрой вставки миксина шрифта - `f`.

#### Вызов эффектов
Стили эффектов *(тени, блюры и тд)* прописываются через миксины в файле `src/scss/abstracts/effects.scss`, там уже есть примеры эффектов.  
Перед каждым миксином нужно выставить префикс `ef-`, чтобы его можно было быстро найти через сниппет. Сниппет для быстрой вставки миксина эффекта - `ef`.

#### rem-функция
Если вы верстаете без использования строгих единиц, таких как пиксели, а пользуетесь относительными единицами, то можете использовать эту функцию, она автоматически преобразует введенное пиксельное значение в rem единицы. Вызывается сниппетом `rem`.

### Адаптивное свойство (lineScale-миксин)
Про миксин lineScale расскажу подробнее. Это так называемое адаптивное свойство. Пример: вы назначаете блоку первоначальную ширину `500px`, а конечную `200px`, при уменьшении экрана от `1440px` до `480px` размер блока будет пропорционально уменьшаться в заданном вами промежутке размера *(500px->200px)*, промежуток экрана так же можно изменять. Можно назначать это свойство для любых элементов *(блоки, шрифты и тд)*. Больше информации о логике работы адаптивного свойства можно найти в интернете.  
Я взял самый распространенный Sass-миксин для реализации этого функционала и доработал его под нужды шаблона. Что было улучшено:
- изменил порядок назначения промежутков размера *(от большего к меньшему);*
- добавил возможность увеличивать блок, а не только уменьшать;
- добавил возможность использовать отрицательные единицы.

#### Пример использования
Сниппет для быстрой вставки lineScale-миксина - `ls`. Миксин после вставки выглядит вот так - `lineScale(,,480,1440)`.  
Разберем, что означает каждый аргумент в этом примере: `lineScale([1],[2],[3],[4])`  
> Все значения указываем в пикселях без единицы измерения *(в конечном итоге они будут автоматически преобразованы в `rem`)*.  
1. Первоначальный размер элемента - `lineScale(500,[2],[3],[4])`
2. Конечный размер элемента - `lineScale(500,200,[3],[4])`
3. До какого размера экрана будет изменяться элемент - `lineScale(500,200,768,[4])`
4. От какого размера экрана будет изменяться элемент - `lineScale(500,200,768,992)`  

**Итого, мы имеем следующее** - размер элемента будет пропорционально уменьшаться от `500px` до `200px` при изменении размера экрана от `992px` до `768px`.

Для визуального облегчения кода можно использовать lineScale-миксин без указания размеров экрана - `lineScale(500,200)`.  
В таком случае они будут заданы по-умолчанию от `1440px` до `480px`.

Пример отрицательного изменения *(пригодится при работе со свойством translate)* - `lineScale(100,-50)`  
Пример обратного изменения *(от меньшего к большему)* - `lineScale(200,500)`

### Систематизация `z-index`

Чтобы на протяжении всей жизни проекта контролировать приоритет наложения блоков и компонентов *(блокировку страницы, модальные окна, всплывающие подсказки и прочие подобные блоки)*, в шаблоне предусмотрена систематизация значений `z-index`.

#### Границы использования:

Верхний порог значений - `z-index: 10`  
Нижний порог значений - `z-index: -1`

#### Правила использования:

| Категория | Значение |
| ------ | ------ |
| Модальные окна | `z-index: 10` |
| Боковое меню | `z-index: 8` |
| Page-lock | `z-index: 6` |
| Фиксированная шапка | `z-index: 4` |
| Оповещения(notify) | `z-index: 4` |

**Важное примечание:** `z-index` для модальных окон и бокового меню учитывается только в том случае, если вы по какой-то неведомой причине решите отказаться от их работы на `dialog` тегах, так как они и так всегда буду выше всего на странице *(и на это пока никак нельзя повлиять)*.

*Все стандартные значения уже заданы в технических стилях стандартных блоков/компонентов;*  
*Промежутки между значениями можно использовать для кастомных блоков/компонентов.*  

### Темизация и работа с темами
*В работе...*


## JS-скрипты

Все скрипты в шаблоне дополнены краткими инструкциями по использованию, которые вы можете найти ниже.  
Скрипты разделены на модули. Основные модули - это функциональные и технические. Подробнее об этом в соответствующих разделах.  

Этот раздел документации может включать следующие блоки:  
- ⚙️НАСТРОЙКИ - данный блок содержит реализованные настройки для скрипта и для того, на что этот скрипт влияет;  
- ❗️ПРИМЕЧАНИЕ - данный блок содержит важные примечания по работе скрипта или информацию о будущих выпусках;  
- 👀ПРИМЕРЫ - данный блок содержит примеры правильной реализации структуры, классов и прочих связанных моментов.  

### Структура JS

	js/
	├── libs/ ---> папка для сторонних библиотек
	│   └── libs.js ---> файл подключения библиотек
	├── modules/ ---> основная директория всех JS-скриптов/модулей
	│   ├── form/ ---> директория для модулей форм
	│   ├── func/ ---> директория для функциональных модулей
	│   ├── lib-control/ ---> директория для файлов-настроек библиотек
	│   ├── tech/ ---> директория для технических модулей
	│   ├── utils/ ---> директория для вспомогательных функций и прочего переиспользуемого
	│   └── custom.js ---> файл для ваших кастомных скриптов проекта
	└── main.js ---> основной объединяющий файл скриптов

### Раздел 1. Технические модули
От этих скриптов зависит работа некоторых функциональных модулей, так что без особой необходимости нет смысла к ним обращаться.  

У технических модулей нет основного файла, так как они вызываются по необходимости внутри функциональных модулей, путь до технических модулей - `js/modules/tech/`.  

#### Модуль 1.1. Блокировка страницы (pageLock)
Содержит функцию для блокировки страницы при вызове выезжающего меню, попапов и тд.  
Блокируется скролл и взаимодействие с любыми элементами страницы, кроме активного.  
При вызове можно добавить кастомный класс.

### Раздел 2. Функциональные модули
Эти скрипты не влияют на работу шаблона, вы можете включить/отключить их по своему усмотрению и необходимости.  

Файл управления функциональными модулями *(где их можно активировать/деактивировать)* расположен по пути - `js/modules/func/index.js`.  

#### <h4 id="getBlockHeight">Модуль 2.1. Получение высоты блоков (getBlockHeight)</h4>
Данный модуль вычисляет высоту блока по его максимальному значению.  

Чтобы вычислить высоту блока, необходимо назначить ему класс `js_get-height`. В этом случае высота блока будет через инлайн-стили записана на ближайший блок с классом `content__block` в переменную `--targetHeight` в rem единицах.  

##### ⚙️НАСТРОЙКИ
Если вам нужно записать значение высоты на определенный блок, то этому блоку задаем класс `js_height-goal`.

##### ❗️ПРИМЕЧАНИЕ
Модуль рассчитан на работу только с одним вычисляемым блоком внутри одного контейнера.

#### <h4 id="initTabs">Модуль 2.2. Табы (initTabs)</h4>

Табы - это несколько ссылок и такое же кол-во привязанных к ним табов *(блоков)*. При нажатии на определенную ссылку открывается привязанный к ней таб, а предыдущий открытый таб пропадает, что позволяет переключаться между табами на странице, выводя разную информацию в одном месте.  

**Примечания по обозначениям:**  
**Контейнер** - это блок, внутри которого расположены ссылки и табы;  
**Ссылка** - это якоря табов, при клике на каждый из которых будет показан свой таб;  
**Контейнер табов** - это блок, внутри которого расположены табы;  
**Таб** - это тело одного таба, в котором будет ваша информация.  

**Ссылки** и **табы** должны быть расположены внутри одного основного **контейнера**.  
Для каждой отдельной группы **табов** свой **контейнер**.  
- указываем класс `js_tab` для основного **контейнера**;
- указываем класс `js_tab-link` для **ссылок**;
- указываем класс `js_tab-content-container` для **контейнера** **табов**;
- указываем класс `js_tab-content` для **табов**;
- указываем класс `active` для одной **ссылки** и одного **таба** *(обычно это первая ссылка и первый таб)*, которые будут показаны изначально *(после загрузки страницы)*;  

**Ссылок** и **табов** должно быть одинаковое количество *(спасибо, кэп)*.  
Внутри основного **контейнера** могут располагаться блоки любой вложенности.  

##### ⚙️НАСТРОЙКИ
Изначально табы работают с `fade-эффектом` *(плавно исчезает текущий и плавно появляется выбранный таб)*, так же плавно подстраивается по высоте контейнер табов.  
Чтобы изменить это поведение, есть пара модификаторов:  
- Указываем класс-модификатор `js_tab--slide` для основного контейнера, чтобы переключить режим анимации в `slide-эффект` *(табы будут замещать друг-друга с плавным изменением высоты)*;
- Указываем класс-модификатор `js_tab--noanim` для основного контейнера, чтобы отключить любую анимацию переключения табов;
- Указываем класс-модификатор `js_tab--empty` для основного контейнера, чтобы включить `пустой режим`. В этом режиме при повторном нажатии ссылки, привязанный к этой ссылке таб будет сворачиваться *(в обычном режиме - его нельзя свернуть)*. *Примечание: этот режим можно использовать для сворачивания какого-либо блока по клику на ссылку*. *Примечание 2: в этом режиме поведение табов будет как в режиме с `js_tab--slide` модификатором*;  

Глобально настроить скорость анимации и саму анимацию можно в файле `tabs.scss`, так же вы можете настроить анимацию конкретных табов, через уникальные классы вашего блока с табами.

##### 👀ПРИМЕРЫ
Стандартную структуру одного блока с табами можно вызвать сниппетом `cmp|tab`.

Пример основного контейнера:

	<div class="tabs-block js_tab">
		<div class="tabs-block__link-list">
			<button class="tabs-block__link js_tab-link active">Ссылка таба 1 (Будет активна изначально благодаря классу active)</button>
			<button class="tabs-block__link js_tab-link">Ссылка таба 2</button>
			<button class="tabs-block__link js_tab-link">Ссылка таба 3</button>
		</div>
		<div class="tabs-block__content-list js_tab-content-container">
			<div class="tabs-block__content js_tab-content active">
				<h1>Контент таба 1 (Будет активен изначально благодаря классу active)</h1>
			</div>
			<div class="tabs-block__content js_tab-content">
				<h1>Контент таба 2</h1>
			</div>
			<div class="tabs-block__content js_tab-content">
				<h1>Контент таба 3</h1>
			</div>
		</div>
	</div>
	*Следующие блоки с табами должны иметь свой класс js_tab (свой контейнер)

#### <h4 id="initSliders">Модуль 2.3. Слайдер (initSliders)</h4>
В работе слайдера за основу взята библиотека `swiper.js`.  
Я упростил инициализацию и добавил несколько наиболее часто используемых настроек.  
Чтобы инициализировать слайдер, добавляем к блоку-родителю *(в котором будут находится непосредственно слайды. Далее - родитель)* класс `js_slider`.  
Для каждого слайда добавляем класс `js_slide`.  
Благодаря предыдущему действию мы можем добавить стрелки управления, пагинацию и прочие элементы `swiper.js` непосредственно в родителя слайдера. Их расположение внутри родителя не имеет значения.  
Так же необходимо задать для родителя data-атрибут `swiper-id` со значением названия слайдера.  
И затем инициализировать по этому классу слайдер в файле `sliders.js`.  
Пример js-инициализации и основные параметры слайдера приведены в вышеуказанном файле. Так же там есть предустановленные настройки для таких модулей как навигация, пагинация и скроллбар, которые нужно использовать для правильной работы предустановленных мной стилей этих модулей.  
Пример блока со слайдером есть в файле `_example.html`.  
Информацию по прочим параметрам можно найти на <a href="https://swiperjs.com/swiper-api#parameters" target="_blank">сайте библиотеки</a>.

##### 👀ПРИМЕРЫ
Можно так:

	<div class="js_slider" data-swiper-id="example-slider">
		<div class="js_slide"></div>
		<div class="js_slide"></div>
		<div class="slider-button-prev"></div>
		<div class="slider-button-next"></div>
	</div>

А можно так:

	<div class="js_slider" data-swiper-id="example-slider">
		<div class="slider-button-prev"></div>
		<div class="js_slide"></div>
		<div class="js_slide"></div>
		<div class="slider-button-next"></div>
	</div>

#### <h4 id="brSpace">Модуль 2.4. Пробелы после тега `<br>` (brSpace)</h4>
Содержит функцию, которая добавляет пробелы после тега `<br>`.  
Требуется в случаях, когда мы скрываем теги `<br>` через css *(перенесенный текст после этого просто сливается, что и исправляет данный скрипт)*.

#### <h4 id="initSpoilers">Модуль 2.5. Спойлеры (initSpoilers)</h4>
Спойлеры *(или аккордеон)* - это один или несколько раскрывающихся элементов. Как пример: часто их работу можно увидеть в блоке FAQ.  
Тут реализована конструкция, которая позволяет инициализировать несколько блоков со спойлерами на странице, которые будут работать независимо.  
Для инициализации создаем блок с классом `js_spoiler`, внутри него складываем сами спойлеры, каждому прописываем класс `js_spoiler-item`. Для каждой отдельной группы спойлеров свой контейнер.  
У спойлера должен быть заголовок и контентная часть, для заголовка указываем класс `js_spoiler-title`, а для контента `js_spoiler-content`.  
Указываем класс `open` для одного из спойлеров, если необходимо, чтобы он изначально был открыт.  
Все эти классы необходимы для гибкости структуры, чтобы между и внутри спойлеров можно было добавлять любые блоки и элементы.  
По умолчанию спойлеры раскрываются независимо друг от друга *(если открыть первый, а затем второй, то первый не закроется)*, чтобы включить одиночный режим, нужно указать соответствующий класс-модификатор *(см. раздел настройки)*.

##### ⚙️НАСТРОЙКИ
- Если добавить к контейнеру спойлеров класс-модификатор `js_spoiler--single`, то при открытии каждого следующего спойлера, предыдущий будет закрываться;

##### 👀ПРИМЕРЫ
Пример одного блока спойлеров:

	<div class="spoiler-list js_spoiler js_spoiler--single">
		<div class="spoiler-list__item js_spoiler-item open">
			<h2 class="spoiler-list__title js_spoiler-title">Заголовок спойлера</h2>
			<div class="spoiler-list__content js_spoiler-content">
				<p>Контент спойлера</p>
			</div>
		</div>
		<div class="spoiler-list__item js_spoiler-item">
			<h2 class="spoiler-list__title js_spoiler-title">Заголовок следующего спойлера</h2>
			<div class="spoiler-list__content js_spoiler-content">
				<p>Контент следующего спойлера</p>
			</div>
		</div>
	</div>
	*Следующие блоки со спойлерами на странице должны иметь свой класс js_spoiler (свой контейнер)

#### <h4 id="scrollToAnchor">Модуль 2.6. Скролл до якоря (scrollToAnchor)</h4>
Скрипт плавно перекидывает на требуемый блок по нажатию ссылки-якоря, но делает это с учетом высоты шапки (требуется в тех ситуациях, когда шапка является липкой).  
Необходимо добавить класс `js_scroll-to` к ссылке-якорю.

##### ❗️ПРИМЕЧАНИЕ
В будущих версиях буду отказываться от этого скрипта в пользу css-решения `scroll-padding`.

##### 👀ПРИМЕРЫ
Пример ссылки-якоря:

	<a class="js_scroll-to" href="#block"></a>

#### <h4 id="initModals">Модуль 2.7. Модальные окна (initModals)</h4>
Модальное окно - это небольшое *(или большое)* всплывающее окошко, которое появляется на странице, при клике на определенные элементы *(как правило - кнопку)*.  
Тут реализовано простое открытие модальных окон на базе тега `<dialog>`, которое можно модернизировать по своему усмотрению *(добавлять анимации, менять поведение и тд)*.  
Вызов модальных окон осуществляется нажатием на элемент-ссылку.  
Закрытие модальных окон осуществляется нажатием на иконку закрытия, на область вне модального окна, по нажатию клавиши `Esc`, а так же нажатию браузерной клавиши "Вернуться назад" или при соответствующем жесте на мобильном устройстве.  
Чтобы создать элемент-ссылку, необходимо задать для тега `<button>` атрибут `data-modal`, которому необходимо назначить идентификатор (`id`) вызываемого модального окна.  
Само модальное окно создается через тег `<dialog>`, которому необходимо присвоить атрибут id, со значением идентификатора модального окна и класс `_modal` *(примеры модальных окон можно найти в файле `modals.html`)*.  
Для контентной части модального окна указываем класс `_modal-content` *(это необходимо для работы прокрутки на мобильных устройствах)*.  

##### 👀ПРИМЕРЫ
Пример кнопки, для открытия модального окна:

	<button data-modal="callback">

Примеры самих модальных окон можно найти в файле `modals.html`.

#### <h4 id="initArticleLogic">Модуль 2.8. Генерация оглавления (initArticleLogic)</h4>
Данный скрипт отвечает за генерацию оглавления для текстовых блоков.  
Требуется для всякого рода статей и блогов, чтобы сгенерировать оглавление с якорными ссылками *(далее - ссылки)* на разделы текста.  
Чтобы сгенерировать ссылки для оглавления, необходимо создать элемент-пример ссылки и задать ему класс `js_article-link`. По подобию этого примера будут сгенерированы все ссылки оглавления.  
Чтобы отметить область контента статьи, необходимо задать для контейнера контента класс `js_article-content`. Внутри данного контейнера будут выбраны все теги `h2` *(далее - цели)* и на них будут сгенерированы ссылки в оглавлении.  
После генерации ссылок, внутри тега ссылки будет расположено содержимое цели, а в атрибуте `href` - ссылка на цель.  
**Важно.** Скрипт заточен под списки `ul>li>a` *(для соблюдения семантики)*. Это значит, что класс `js_article-link` должен находиться на теге `<li>`, внутри которого уже будет тег `<a>`, которому и будет назначен атрибут `href` *(смотреть **пример ссылки**)*.

##### ⚙️НАСТРОЙКИ
Идентификатор целей *(по-умолчанию - `h2`)* можно сменить в файле модуля `src/js/modules/func/initArticleLogic.js` *(там будет пометка в виде комментария)*

##### ❗️ПРИМЕЧАНИЕ
Скрипт так же добавляет свой технический класс `js_article-target` к целям.  
Данный класс нужен для работы `скрипта 2.9`.

##### 👀ПРИМЕРЫ
Пример ссылки:

	<ul class="article__list">
		<li class="article__list-item js_article-link"><a class="article__list-link">Ссылка-пример для оглавления</a></li>
		// тут будут сгенерированы остальные ссылки, а ссылка-пример удалиться.
		// вот пример уже сгенерированных ссылок:
		<li class="article__list-item js_article-link"><a href="#target-0" class="article__link">Заголовок 1</a></li>
		<li class="article__list-item js_article-link"><a href="#target-1" class="article__link">Заголовок 2</a></li>
	</ul>
Пример контента статьи:

	<div class="article__content js_article-content">
		<h2>Заголовок 1</h2>
		<p>Lorem ipsum dolor sit amet, consectetur adipisicing elit. Sint commodi provident, explicabo vel corporis itaque fuga repellat at, eius minima qui tempora, a amet doloribus cupiditate ipsam voluptate veritatis modi.</p>
		<h2>Заголовок 2</h2>
		<p>Lorem ipsum dolor sit amet, consectetur adipisicing elit. Sint commodi provident, explicabo vel corporis itaque fuga repellat at, eius minima qui tempora, a amet doloribus cupiditate ipsam voluptate veritatis modi.</p>
	</div>
	// и вариант после генерации оглавления:
	<div class="article__content js_article-content">
		<h2 id="target-0" class="js_article-target">Заголовок 1</h2>
		<p>Lorem ipsum dolor sit amet, consectetur adipisicing elit. Sint commodi provident, explicabo vel corporis itaque fuga repellat at, eius minima qui tempora, a amet doloribus cupiditate ipsam voluptate veritatis modi.</p>
		<h2 id="target-1" class="js_article-target">Заголовок 2</h2>
		<p>Lorem ipsum dolor sit amet, consectetur adipisicing elit. Sint commodi provident, explicabo vel corporis itaque fuga repellat at, eius minima qui tempora, a amet doloribus cupiditate ipsam voluptate veritatis modi.</p>
	</div>

#### <h4 id="initArticleLogic">Модуль 2.9. Отслеживание оглавления (initArticleLogic)</h4>
Иногда нужно добавить отслеживание оглавления *(когда юзер долистал до определенного заголовка в статье, то ссылка на этот заголовок в оглавлении подсвечивается)*.  
Хороший пример - когда оглавление и статья расположены в row flex-контейнере и оглавление имеет position: sticky свойство. То есть, оглавление следует за скроллом и всегда видно, где сейчас находится юзер.  
Данный скрипт работает в автоматическом режиме и не требует каких-либо манипуляций с html-структурой.  
Ссылка, до заголовка которой долистал юзер - приобретает класс `active`. Если в зоне видимости появляется другой заголовок, класс `active` у предыдущего пропадает.

##### 👀ПРИМЕРЫ
Пример полного блока с генерацией оглавления и отслеживанием есть в файле `_example.html`

#### <h4 id="initNotify">Модуль 2.10. Оповещения (initNotify)</h4>
Оповещения - это небольшие окошки, которые будут оповещать пользователя о тех иных действиях, которые он делает.  
Работают они на новых `popover` элементах. Что делает их максимально производиетльными.  
Вызов оповещения осуществляется нажатием на элемент-ссылку.  
Закрытие оповещений осуществляется нажатием на иконку закрытия, на область вне оповещения, по нажатию клавиши `Esc`, а так же по прошествии заданного количества времени.  
Чтобы создать элемент-ссылку, необходимо задать для любого тега атрибут `popovertarget`, которому необходимо назначить идентификатор вызываемого оповещения.  
Так же желательно назначить атрибут `popovertargetaction`, со значением `show` *(подробнее обо всех возможностях `popover` можно прочитать например <a href="https://doka.guide/html/popover/" target="_blank">тут</a>)*.  
Само оповещение создается через добавление к любому блоку атрибута `popover` и атрибута `id`, со значением идентификатора оповещения *(примеры оповещений можно найти в файле `modal.html`)*. Так же необходимо задать класс `js_notify`.

##### ⚙️НАСТРОЙКИ
Если вам необходимо показывать оповещение сразу после загрузки страницы, необходимо добавить класс `open` к блоку-оповещению, а к атрибуту `popover` добавить значение `manual`.  
Например, это необходимо для окошка с cookie-оповещением *(см. [Модуль 2.11](#initCookie))*.  

Так же можно задать время, через которое будет закрыто оповещение.  
Чтобы это сделать, необходимо добавить к блоку-оповещению data-атрибут `data-popover-time` со значением времени в секундах.  
Если не задавать атрибуту значение, то будет применено стандартное в 3 секунды.

##### 👀ПРИМЕРЫ
Пример элемента, для показа оповещения:

	<button popovertarget="addToCart" popovertargetaction="show">Добавить в корзину</button>

Примеры самих оповещений можно найти в файле `modal.html`.

#### <h4 id="initCookie">Модуль 2.11. Куки-оповещалка (initCookie)</h4>
Здесь у нас скрипт, который отвечает за добавление в `localStorage` информации о том, что пользователь согласен с использованием cookie.  
Само окошко работает на Оповещениях *([Модуль 2.10](#initNotify))*, стили отделяют cookie-оповещение от обычного по `id="cookie"` *(стили находятся в файле `src/scss/components/cookie.scss`)*.

##### 👀ПРИМЕРЫ
Пример окошка с оповещением можно найти в файле `modal.html`.

#### <h4 id="copyWithClick">Модуль 2.12. Копирование текста в буфер (copyWithClick)</h4>
Скрипт на копирование любого текста по клику на элемент.  
Для работы скрипта необходимо добавить к элементу data-атрибут `data-copy` со значением, которое нужно скопировать. По клику на этот элемент текст из атрибута будет скопирован в буфер пользователя.

#### <h4 id="detectUserInfo">Модуль 2.13. Детектирование системы и браузера (detectUserInfo)</h4>
Содержит скрипт для детектирования системы и браузера пользователя. Записывает результат детектирования в классы к тегу `body`.  
Идентификаторы системы и браузера, которые появятся у `body`:
- `system-win` - система Windows;
- `system-mac` - система MacOS;
- `system-unix` - система Unix;
- `system-linux` - система Linux;
- `system-iphone` - смартфон iPhone;
- `browser-chrome` - браузер Chrome;
- `browser-yandex` - браузер Yandex;
- `browser-edge` - браузер Microsoft Edge;
- `browser-opera` - браузер Opera;
- `browser-firefox` - браузер Firefox;
- `browser-safari` - браузер Safari;
- `browser-explorer` - браузер Internet Explorer *(wtf)*.

> Если система или браузер не определены, добавятся классы `system-unknown` и `browser-unknown` соответственно.

#### <h4 id="calcHeaderHeight">Модуль 2.14. Высота шапки (calcHeaderHeight)</h4>
Добавляет на тег `<body>` переменную с высотой шапки на странице.  
Может пригодиться в разных ситуациях, например, чтобы добавить верхний отступ на странице, когда шапка является фиксированной.

#### <h4 id="calcScrollbarWidth">Модуль 2.15. Ширина полосы прокрутки (calcScrollbarWidth)</h4>
Добавляет на тег `<body>` переменную с шириной полосы прокрутки *(кроссбраузерно)*.  
Может пригодиться в разных ситуациях, например, чтобы добавить отступ для фиксированной шапки, при добавлении свойства `overflow: hidden` на `<body>` *(ждем, когда `scrollbar-gutter: stable` научится в fixed-position ¯\\_(ツ)_/¯)*.  
***Интересный факт:** в Edem-шаблоне шапка реализована на position: sticky, что избавляет нас от проблемы с прыгающим контентом из-за overflow: hidden/clip.*  

#### <h4 id="detectPageLoad">Модуль 2.16. Детектор загрузки страницы (detectPageLoad)</h4>
Добавляет для тега `<body>` класс `load-dom`, когда было загружено DOM-дерево, и класс `load`, когда страница была загружена полностью *(внешние ресурсы, картинки, стили и тд)*.

##### ❗️ПРИМЕЧАНИЕ
**Важно!** Не рекомендуется использовать это для анимации блоков при загрузке страницы, так как если скрипты js не загрузятся или произойдет сбой, то пользователь не увидит контент, который будет скрыт стилями.  
Вместо этого стоит обратить внимание на нативное css-решение `@starting-style`.

#### <h4 id="detectPageScroll">Модуль 2.17. Детектор прокрутки страницы (detectPageScroll)</h4>
Добавляет для тега `<body>` класс `scroll`, когда страница прокручена на `100px`, и удаляет этот класс, когда прокрутка меньше `100px`.

#### <h4 id="initTooltip">Модуль 2.18. Тултипы (initTooltip)</h4>
Тултипы - это небольшие всплывающие окошки, в которых, как правило, находится какая-то справочная информация.  
Вызов тултипа осуществляется наведением на элемент-ссылку.  
Чтобы создать тултип, необходимо блоку-контейнеру задать класс `js_tooltip`, а внутри создать два контейнера: для элемента-ссылки с классом `js_tooltip-button` и для самого тела тултипа с классом `js_tooltip-body`.  
Внутрь тела тултипа вставляем необходимый текст *(или любой другой контент)*. А внутрь элемента-ссылки информационную иконку *(или любой другой контент)*.  

##### ❗️ПРИМЕЧАНИЕ
Заготовку тултипа можно вставить сниппетом `cmp|tooltip`.

##### 👀ПРИМЕРЫ
Пример тултипа можно найти в файле `src/html/_example.html`.

### Раздел 3. Формы
Все скрипты форм располагаются по пути `src/js/modules/form/`. Основным файлом является `index.js`.  
Все примеры реализации модулей форм можно увидеть в файле `src/html/_example.html`.

#### Общие скрипты
Общие скрипты находятся в центральном файле `index.js`.  

**Сообщение об отправке формы (MODX)**  
Этот скрипт добавляет на кнопку отправки формы класс `send`, когда форма успешно отправлена.

> Этот скрипт работает исключительно при использовании CMS MODX и расширения FetchIt, если вы не используете CMS, спокойно удалите его.

**Работа библиотеки iodine (MODX)**  
Этот скрипт отвечает за работу библиотеки iodine при отправе формы, для валидации и показа ошибок.

> Этот скрипт работает исключительно при использовании CMS MODX и расширения FetchIt, если вы не используете CMS, спокойно удалите его.

#### Модуль 3.1. Логика поля ввода номера телефона (telInput)
Этот модуль отвечает за маску номера телефона. Работает на основе библиотеки <a href="https://github.com/uNmAnNeR/imaskjs" target="_blank">iMask</a>.  
Чтобы применить скрипт к полю ввода, необходимо назначить ему класс `_tel-mask`.

#### Модуль 3.2. Логика выпадающего списка (select)
Этот модуль отвечает за выпадающий список.  
Выпадающие списки работают нативно, поэтому здесь присутствует только логика применения классов, при взаимодействии с выпадающим списком. Тем не менее, класс `_select` необходимо назначить, чтобы работали технические стили.

#### Модуль 3.3. Логика числового поля ввода инпута (numberInput)
Этот модуль отвечает за числовое поле ввода с `+` `-` кнопками изменения значения.  

##### ⚙️НАСТРОЙКИ
Через атрибуты полю ввода можно назначить:
- минимальное значение через атрибут `min`
- максимальное значение через атрибут `max`
- шаг изменения значения через атрибут `step`
- начальное значение через атрибут `value`

#### Модуль 3.4. Логика ползунка (rangeInput)
Этот модуль отвечает за ползунок выбора значения.

##### ⚙️НАСТРОЙКИ
Через атрибуты ползунку можно назначить:
- минимальное значение через атрибут `min`
- максимальное значение через атрибут `max`
- шаг изменения значения через атрибут `step`
- начальное значение через атрибут `value`

#### Модуль 3.5. Логика двойного ползунка (dualRangeInput)
Этот модуль отвечает за ползунок выбора значения.

##### ⚙️НАСТРОЙКИ
Через атрибуты ползунку можно назначить:
- минимальное значение через атрибут `min`
- максимальное значение через атрибут `max`
- шаг изменения значения через атрибут `step`
- начальное значение через атрибут `value`

##### ❗️ПРИМЕЧАНИЕ
Атрибуты настроек необходимо назначить только первому ползунку в группе, второй ползунок сам подтянет их из первого.

#### Модуль 3.6. Логика файлового поля ввода (fileInput)
Этот модуль отвечает за файловое поле ввода.
Файловое поле ввода работает нативно, поэтому здесь присутствует только логика применения классов, при взаимодействии с выпадающим списком и подстановки названия файла. Тем не менее, класс `js_file` и `js_file-input` необходимо назначить, чтобы работали технические стили.

### Работа со сторонними библиотеками
В шаблоне используются некоторые сторонние библиотеки.  
Я стараюсь не перегружать шаблон всяким хламом, а добавляю только действительно полезные компоненты и полифилы.

#### Слайдер (Swiper)
Здесь представлена информация по использованию библиотеки <a href="https://swiperjs.com" target="_blank">Swiper</a>.  
Я использую данную библиотеку, если мне нужен нестандартный функционал слайдера *(зацикливание, пагинация, скроллбар, эффекты и тд)*. Во всех остальных случаях хватает нативного CSS Scroll Snap функционала.  
Логика работы библиотеки описана в [соответствующем разделе](#initSliders).

#### Видео-плеер (Plyr)
Здесь представлена информация по использованию библиотеки <a href="https://plyr.io" target="_blank">Plyr</a>.  
Я использую данную библиотеку, если мне не подходит нативный плеер в реализации задач.  
Все файлы библиотеки уже подключены, а моя самая популярная конфигурация для плеера лежит в файле `src/js/modules/lib-control/videoplayers.js`. В этом же файле можно прописывать конфигурации для ваших плееров.

#### Галереи (Fancybox)
Здесь представлена информация по использованию библиотеки <a href="https://fancyapps.com/fancybox/" target="_blank">Fancybox</a>.  
Я использую данную библиотеку, если мне нужны всплывающие изображения, которые внутри содержат простую галерею *(или без нее)*. Она хорошо работает и предоставляет весь необходимый функционал, а так же из коробки есть связь со слайдерами, реализованными посредством `Swiper.js`.  
Все файлы библиотеки уже подключены, а моя самая популярная конфигурация для всплывающих изображений лежит в файле `src/js/modules/lib-control/galleries.js`. В этом же файле можно прописывать конфигурации для ваших галерей.

#### Scroll-timeline polyfill
Это полифил, который заменяет еще недоступный в некотороых браузерах функционал scroll-timeline.  
Файл с заготовленными анимациями находится по пути `src/scss/base/timeline.scss`.  

Пример вызова:

	animation: fade-in-bottom linear;
	animation-timeline: view(block);
	animation-range: 0 250px; <-- Тут используются пиксели, так как в полифиле возникают проблемы с относительными единицами (сафари и файрфокс), если это вас не парит, используйте следующую конструкцию:
	animation-range: 0 38dvh;

С подробными настройками по `scroll-timeline` можно ознакомиться на просторах интернета.


## Работа с изображениями и иконками

### Оптимизация изображений
Оптимизация изображений работает только в билд режиме.

### <h3 id="svg-generation">Генерация SVG-спрайта (работа с иконками)</h3>
Иконки в шаблоне реализованы через svg-спрайт *(подробнее об этом методе ниже)*.  
Для работы с иконками я написал простой плагин `svg-remove-fill`, который помогает оптимизировать иконки для последующего создания svg-спрайта.  

### svg-remove-fill
Плагин `svg-remove-fill` меняет **black** значение заливки иконок на **currentColor**, что позволяет манипулировать цветом иконок из `CSS`.  
При этом, плагин не трогает отличающиеся от **black** значения, чтобы была возможность использовать многоцветные иконки.  

#### Краткая инструкция/рекомендация  
*(при экспорте иконок из Figma)*
1. Необходимо собрать все используемые в дизайне иконки;
2. К иконкам необходимо применить функцию `Outline stroke` *(Figma Menu ➔ Object ➔ Outline stroke)*, так как иконки не должны содержать контурные линии *(обводку)*, а должны являться сплошным векторным объектом;
3. Каждую иконку поместить в свой квадратный фрейм с подходящим названием *(рекомендую использовать именно квадратные фреймы, так как будет проще позже встраивать их на сайт)*;
4. Выделить все икноки и поменять их цвет *(кроме многоцветных)* на черный `#000000`;
5. Если иконка многоцветная, то поменять заливку на черную только в тех частях иконки, цвет которых необходимо будет менять средствами `CSS`;
6. Далее экспортируем иконки в формате svg в директорию `src/img/icons`;
7. Внутри данной директории можно создавать поддиректории, для сортировки иконок по значению *(в таком случае иконка будет доступна в `HTML/CSS` через конструкцию вида - `название_папки-название_иконки`)*;
8. После запуска сборки иконки будет доступны через спрайт `build/img/sprite.svg`;

#### Примеры вызова иконок  
**HTML**  
`<svg class="icon" width="32" height="32"><use href="img/sprite.svg#название_иконки"></use></svg>`  
**Класс `icon` является обязательным, на него завязаны технические стили для иконок*  
**Данную конструкцию можно быстро вызвать через сниппет svg*  

**CSS**  
`url(../img/sprite.svg#название_иконки)`

### Подробнее об svg-спрайтах
**SVG-спрайт** - это некий сборник всех иконок, которые нужны вам на сайте, они все собраны в одном svg-файле, но их можно вывести каждый отдельно, указав нужный идентификатор. Такой подход экономит ваше время и силы, а так же не оказывает негативного влияния на оптимизацию сайта.  

Основным преимуществом использования svg-спрайтов является возможность стилизовать иконки через CSS-стили. Мы можем менять размер, цвет, фон иконок, а также — менять стили при наведении.  


## Шрифты
В шаблоне реазиована автоматическая генерация шрифтов и сделаны заготовки под вызов и назначение шрифтов на сайте.

### Генерация файлов шрифтов
Первым делом вам необходимо положить шрифты формата `ttf` в папку `src/fonts/`.
Если сборка уже запущена, то она распознает изменения в папке шрифтов и запустит задачу генерации. Если сборка не запущена, можете запустить задачу автоматически через консольную команду `gulp font`.

### Подключение шрифтов
После генерации шрифтов нужно перейти в файл `src/scss/base/fonts.scss` и следуя инструкции внутри файла подключить добавленные шрифты.

### Назначение заготовок стилей шрифтов
Если вы верстаете сайт по макету из Figma, вероятнее всего там есть стили шрифтов, которые задает дизайнер с прямыми руками.  
Используя Figma-расширение `Global style to code`, вы можете скопировать эти стили в scss-формат и использовать их для быстрого вызова в шаблоне.  
Для этого есть файл `src/scss/abstracts/font-styles.scss`, в который и нужно вставить скопированные стили шрифтов. А затем привести их к общему виду, как в примерах в этом файле.  
Для вызова заготовок стилей, воспользуйтесь сниппетом `f`.

#### reductFont
**Данная функция работает в тестовом режиме, не гарантируется стабильность ее работы.**  
Функция `reductFont` позволяет минимизировать затраты времени на подгон шрифтов под мобильные устройства.  
Логика функции следующая: она берет изначальное значение шрифта и конвертирует его по своеобразной обратной геометрической прогрессии. Чем больше изначальное значение шрифта – тем большее значение отнимается от него для мобильной версии.  

На примере это выглядит так:
- Изначальный шрифт в `13px` становится `12px`;  
- Изначальный шрифт в `16px` становится `14px`;  
- Изначальный шрифт в `20px` становится `16px`;  
- Изначальный шрифт в `36px` становится `20px`;  
- Изначальный шрифт в `64px` становится `24px`;  
- И так далее..  

Это наиболее оптимальный вариант автоматического преобразования шрифтов для мобильных версий сайтов. 


## <h2 id="vscode-dependent">Зависимые файлы VSCode</h2>
К шаблону прилагается профиль EdemGulpTemplateProfile *(версия для MacOS и Windows)*, который позволит вам использовать все зависимые файлы, связанные с редактором VSCode.  
Инструкция по интеграции профиля шаблона уже была в разделе [Интеграция зависимых файлов шаблона](#интеграция-зависимых-файлов-шаблона).  
Далее идет перечень основных файлов, которые добавляет профиль.

### Сниппеты
Небольшие фрагменты, которые позволяют ускорить разработку.  
**Работают они так:** вы назначаете какому-либо куску кода значение быстрого вызова и в дальнейшем можете вызывать этот код через короткий вызов.  
Чтобы открыть файл со сниппетами, используем команду VSCode `Фрагменты кода: Настройка фрагментов`. После выбора этой команды откроется список доступных файлов со сниппетами. Вам нужно выбрать `edemTemplate.code-snippets (Фрагмент кода рабочей области)`. Внутри файла можете ознакомится с доступными сниппетами.

#### Самые важные сниппеты
РАЗДЕЛ В РАЗРАБОТКЕ

### <h3 id="keybindings">Сочетания клавиш</h3>
Большинство сочетаний клавиш я настраивал под себя годами. Все они были подобраны с оглядкой на опыт в разработке веб-сайтов, поэтому должны быть удобны и функциональны, чтобы максимально ускорить и упростить процесс разработки.  
Это пожалуй самая сложная часть освоения шаблона, так как изучение новых сочетаний всегда дается трудно, но пройдя один-два проекта с этим набором вы запомните их на интуитивном уровне и поймете их преимущества *(проверено лично, при переходе с Windows на Mac)*.  
Если какие-то сочетания покажутся вам нелогичными или неудобными, ничего страшного, можете настроить их под себя и дать обратную связь *(возможно я увижу в ваших вариантах преимущества и внесу их в шаблон)*.  

Сочетания указаны как для Windows-систем, так и для MacOS.

*Для некоторых сочетаний требуются дополнительные VSCode-расширения (указаны в квадратных скобках).*

| Действие | Сочетание клавиш (🪟Windows) | Сочетание клавиш (🍎MacOS) |
| ------ | ------ | ------ |
| Запуск dev-задачи (старт шаблона для разработки) | **Alt + E** | **Command + E** |
| Запуск build-задачи (сборка проекта для продакшена) | **Alt + Shift + E** | **Command + Option + E** |
| Остановка любой задачи | **NaN** | **Command + Shift + E** |
| Показать список всех задач сборки | **Ctrl + Shift + E** | **Option + Shift + E** |
|  |  |  |
| Закрыть текущую вкладку | **NaN** | **Command + Shift + W** |
| Закрыть окно редактора | **NaN** | **Command + Q** |
|  |  |  |
| Дублировать активный файл `[расш. File Utils]` | **Ctrl + D** | **Command + D** |
| Переименовать активный файл `[расш. File Utils]` | **Ctrl + Shift + D** | **Command + Shift + D** |
|  |  |  |
| Выделить следующее вхождение *(выделите одно слово, нажмите сочетание, и следующее совпадение будет выделено, повторите)* | **Ctrl + L** | **Command + L** |
| Выделить предыдущее вхождение | **Ctrl + Alt + L** | **Command + Option + L** |
| Выделить все вхождения | **Ctrl + Shift + L** | **Command + Shift + L** |
|  |  |  |
| Список последних проектов | **Ctrl + R** | **Command + R** |
|  |  |  |
| Форматировать текущий файл | **Alt + Shift + F** | **Option + Shift + F** |
| Форматировать выделенный фрагмент | **NaN** | **Control + Shift + F** |
|  |  |  |
| Построить scss-дерево из выделенного html-кода `[расш. eCSStractor for VSCode]` | **Ctrl + Alt + C** | **Option + Command + C** |
| То же самое, но с комментариями `[расш. eCSStractor for VSCode]` | **Shift + Ctrl + Alt + C** | **Control + Command + C** |
|  |  |  |
| Поиск по активному файлу | **Ctrl + F** | **Command + F** |
| Поиск в проекте по файлам | **Ctrl + Shift + F** | **Command + Shift + F** |
| Поиск вхождения в проекте | **Ctrl + Alt + F** | **Command + Option + F** |
| Дерево тегов, классов, функций и тд с удобным переходом в активном файле | **Ctrl + Shift + .** | **Command + Shift + .** |
| Поиск в проекте по тегам, классам, функциям и тд | **Ctrl + T** | **Command + T** |
| Свернуть выделенные блоки кода | **Ctrl + Shift + Num-** | **Command + Shift + Backspace** |
| Выделить текущий тег (или содержимое тега) | **Ctrl + W** | **Command + W** |
| Обернуть выделенный фрагмент в любой тег | **Alt + Shift + W** | **Command + Option + W** |
| Соединить несколько строк в одну | **Ctrl + J** | **Command + J** |
| Перейти к закрывающей/открывающей скобке (любой) | **NaN** | **Command + Shift + \\** |
| Предыдущая вкладка редактора (предыдущий файл) | **NaN** | **Command + Shift + \[** |
| Следующая вкладка редактора (следующий файл) | **NaN** | **Command + Shift + \]** |
| Показать представление (выпадающий список с подсказками) | **Ctrl + Space** | **Command + Space** |
|  |  |  |
| Показать/скрыть терминал, поставить курсор в терминал (если показан) | **Ctrl + ~** | **Command + ~** |
| Показать/скрыть боковую панель | **Ctrl + B** | **Command + B** |
| Поставить курсор в проводник и обратно | **Ctrl + Shift + E** | **Command + Shift + B** |
|  |  |  |
| Создать новый файл в любой директории по выбору `[расш. File Utils]` | **Ctrl + Alt + N** | **Option + Command + N** |
| Создать новую папку в любой директории по выбору `[расш. File Utils]` | **Ctrl + Alt + N** | **Control + Command + N** |
| Расставить числа по порядку от/до (при выделении нескольких строк) `[расш. vscode-input-sequence]` | **Ctrl + Alt + 0** | **Option + Command + 0** |
|  |  |  |
| "Оттипографировать" выделенный текст `[расш. typograf]` | **Alt + T** | **Option + Shift + T** |
|  |  |  |
| Вставить BEM-элемент `[расш. BEM Helper]` | **Ctrl + Num-** | **Command + \\** |
| Вставить BEM-модификатор `[расш. BEM Helper]` | **Ctrl + Num*** | **Command + Option + \\** |

***примечение:** на MacOS необходимо отключить некоторые системные сокращения, чтобы они работали в VSCode *(напр. `Command + Space`, `Command + ~` и тд)*. `Системные настройки ➔ Клавиатура ➔ Сочетания клавиш ➔ Снять галочку/переназначить сочетание`, затем перезагрузить VSCode.  

### Переключение языка
Пока мы далеко не отошли от темы сочетаний клавиш, поговорим немного о переключении раскладки клавиатуры.  
Если вы пользуетесь поиском Spotlight или переключением языка на MacOS по сочетанию `Command + Space`, то спешу вас огорчить, что это не эффективно *(это касается и Windows с его `Alt+Shift` или даже `Ctrl+Shift`)*. Самой быстрой кнопкой [на диком западе] для переключения языка *(по моему скромному мнению)* является `Caps Lock`.  

**Caps Lock на MacOS**  
Сделать переключение языка по нажатию `Caps Lock` на MacOS не сложно, это позволяет сделать сама система, через настройки клавиатуры. Но даже при таком *(казалось бы)* простом решении – есть косяк. Переключение очень часто опаздывает, и если вы быстро начнете печатать после переключения – выйдет бессмыслица, так как язык не успеет переключится. К тому же постоянно всплывающее окошко с оповещением о переключении раздражает.  
Выход есть, это <a href="https://github.com/Nikeev/LangSwitch" target="_blank">LangSwitch</a> *(не путать с Lang Switcher)* – небольшое приложение, которые убирает все задержки при переключении языка по клавише `Fn/🌐`.  Нам остается только поменять клавишу `Caps Lock` и `Fn` местами в настройках клавитауры MacOS и будет счастье.

**Caps Lock на Windows**  
Что касается Windows – тут немного сложнее. Из коробки он не дает возможности переключать языки по `Caps Lock`. Но это же Windows, для которой существуют сотни тысяч различных программ.  
Лично я настроил переключение языка на Windows по `Caps Lock` с помощью макросов клавиатуры, которая поддерживает VIA.  
Если у вас обычная клавиатура без макросов, то можно воспользоваться всем известным скриптовым языком <a href="https://www.autohotkey.com/" target="_blank">AutoHotkey</a>.


### Настройки задач
Этот файл отвечает за заготовки задач сборки *(которые уже упоминались в документации в разделе [Установка и запуск](#установка-и-запуск))*.

### Настройки VSCode
Этот файл отвечает за настройки самого редактора и расширений.

### Рекомендованные расширения
Разделю этот список на два, первый будет "обязательным", второй - второстепенным.  
Все описания расширений будут связаны исключительно с шаблоном *(что они делают и как помогают в рамках шаблона)*.  
Расширения в любом случае устанавливаются все *(из профиля EdemGulpTemplateProfile)*, но вы можете отключать какие-то необязательные по своему усмотрению.  

**"Обязательный" список расширений:**
- **File Utils** позвоялет быстро дублировать или переименовать текущий открытый файл, а так же быстро создавать новые файлы или папки по любому пути;
- **eCSStractor for VSCode** позволяет из выделенного фрагмента HTML-кода собрать scss-заготовку для вставки в scss-файл;
- **BEM Helper** позволяет вставить BEM-блок с заготовкой класса от родителя;
- **vscode-input-sequence** позволяет быстро вставить последовательную нумерацию, от любого заданного числа;
- **todo tree** добавляет дерево задач типа todo;
- **todo highlight v2** раскрашивает задачи в цвета, в зависимости от типа задачи;
- **SFTP** позволяет настроить автоматический деплой на сервер, при изменении файлов в проекте;
- **Better Comments** раскрашивает комментарии, если указать определенный знак перед ним;
- **typograf** "типографирует" выделенный текст по заветам моего однофамильца Артемия (<a href="https://www.artlebedev.ru/typograf/" target="_blank">ссылка на типограф</a>, чтобы понять что это такое);

**Второстепенный список расширений:**  
- **Colorize** раскрашивает все цветовые коды в css коде;
- **CSS Navigation** улучшает навигацию css/scss;
- **Image preview** отображает превью изображения, если в строке есть ссылка на изображение;
- **Path Autocomplete** отображает в подсказке вложенные папки и файлы, если начать вводить путь;

## Система маркеров задач
В шаблоне используется система маркеров задач, для ведения рабочего todo-листа. Для обработки маркеров необходимо установить VSCode-расширения `todo tree` и `todo highlight v2`. Все это будет работать после применения профиля шаблона.

### Как это работает?
В том месте, где нужно пометить себе задачу, прописать сниппет `com|todo`, который автоматически вставит комментарий с выбором маркера, в зависимости от расширения файла. Описать задачу после двоеточия и забыть про нее на какое-то время. А когда придет момент для правок, зайти в интерфейс `todo tree` расширения и закрыть все задачи (или не закрывать, решать вам).  

### Типы маркеров
Ниже представлен список типов маркеров, используемых в шаблоне и их предназначение:

🟡 **ЗАДАЧА:** - обычная задача, не требующая срочного вмешательства;  
🔵 **ДОРАБОТКА:** - задача, которая переносит работу "на потом";  
🔴 **СРОЧНО:** - задача, которая требует немедленного вмешательства;  
🟤 **КОСТЫЛЬ:** - напоминание о том, что тут есть костыль;  
🟠 **БАГ:** - напоминание о том, что тут есть баг;  
⚫ **TODO:** - просто маркер для отслеживания чужих задач;


<!-- ## Работа с favicon
РАЗДЕЛ В РАЗРАБОТКЕ -->

<!-- ### Генерация и подключение -->

<!-- ### Рекомендации по использованию -->


## Автоматический деплой на сервер
Для автоматического деплоя на тестовый или боевой сервер я использую VSCode-расширение <a href="(https://github.com/Natizyskunk/vscode-sftp)" target="_blank">SFTP</a>.  
После его установки используем команду VSCode `SFTP: Config`, для создания конфига в директории `.vscode/sftp.json`.  
Далее в сгенерированный файл вставляем следующую json-заготовку под работу с хостингом

	{
		"name": "[указываем имя проекта]",
		"host": "[указываем ip-адрес для доступа к ftp из ЛК хостинга]",
		"protocol": "ftp",
		"port": 21,
		"username": "[логин от ftp-аккаунта на хостинге]",
		"password": "[пароль от ftp-аккаунта на хостинге]",
		"remotePath": "[путь до папки на хостинге, куда будем заливать файлы, можете скопировать путь из ftp-проводника]",
		"context": "./build",
		"uploadOnSave": false,
		"watcher": {
			"files": "**/*",
			"autoUpload": true,
			"autoDelete": false
		}
	}

Готово, теперь при изменении каких-либо файлов внутри папки build *(сборка должна быть запущена)* они будут отправлены на сервер.


## Скрипты для MODX
В шаблоне можно найти несколько скриптов, которые связаны с CMS MODX *(система управления контентом сайта)*. Они здесь, так как я часто работаю с этим "движком". Если вы так же работаете с MODX, они будут для вас полезны, если нет — удалите их. Все, что связанно с MODX находится в файле `src/js/modules/form/index.js` и `src/js/libs/libs.js` *(помечены комментариями)*.


## Полезные советы
**Раздел дополнится после получения обратной связи**

<!-- ### Подсказки для верстальщиков-новичков -->


## Часто задаваемые вопросы
**Раздел дополнится после получения обратной связи**

## Заключение
Текст для этого раздела сгененирован ИИ, но он получился так себе, так что пусть тут будет баклажан 🍆

### Благодарности
Пока могу поблагодарить лишь себя любимого)

### Контакты для обратной связи
Если у вас есть вопросы, предложения или вы нашли баг, пожалуйста, свяжитесь со мной:  
- **Telegram:** <a href="https://t.me/korgmen" target="_blank">@Korgmen</a>
- **GitHub:** открывайте issues для багов или предложений
- **Email:** <a href="mailto:korgmen@yandex.ru">korgmen@yandex.ru</a>  

**Поблагодарить за труды:** <a href="https://boosty.to/korgmen/donate" target="_blank">Бусти</a>

### Планы на будущее развитие шаблона
**Edem Template** — это живой проект, который будет развиваться и поддерживаться.  

- Добавить линтеры и конфиги
- Переработка логики технических классов и стилизации привязанных к ним компонентов (сейчас есть небольшая путаница с этим)
- Настроить нативную валидацию форм
- Перевод документации

<!-- ## Приложения
РАЗДЕЛ В РАЗРАБОТКЕ -->

<!-- ### Полный список зависимостей -->

<!-- ### Примеры кода и сниппетов -->

<!-- ### Ссылки на документацию используемых библиотек -->


<!-- ## GIT-нейминг или "Как правильно коммитить"
РАЗДЕЛ В РАЗРАБОТКЕ -->

[К началу](#edem-template---документация)